#include <iostream>
#include "../incl/graph.h"

#include "boost/graph/random.hpp"
#include "boost/random/mersenne_twister.hpp"

#include <boost/graph/edge_list.hpp>
#include <boost/graph/bellman_ford_shortest_paths.hpp>

int main()
{
    // ID numbers for the routers (vertices).
    // Specify the graph type and declare a graph object
    typedef std::pair < int, int >Edge;
    typedef boost::edge_list < Edge*, Edge, std::ptrdiff_t, std::random_access_iterator_tag> Graph;

    // The list of connections between routers stored in an array.
    Edge edges[] = {
        Edge(0, 1),
        Edge(0, 2),
        Edge(1, 3),
        Edge(1, 4),
        Edge(2, 4),
        Edge(2, 5),
        Edge(3, 7),
        Edge(3, 4),
        Edge(4, 7),
        Edge(5, 6),
        Edge(6, 7)
    };

    int n_edges = sizeof(edges)/sizeof(Edge);
    int n_vertices = 8;
    Graph g(edges, edges + n_edges);

    // The transmission delay values for each edge.
    float edges_costs[] =
        {5.0, 1.0, 1.3, 3.0, 10.0, 2.0, 6.3, 0.4, 1.3, 1.2, 0.5};

    // Declare some storage for some "external" vertex properties.
    int pred[n_vertices];

    for (int i = 0; i < n_vertices; ++i) pred[i] = i;
    float distance[n_vertices];
    std::fill(distance, distance + n_vertices, (std::numeric_limits < float >::max)());
    // Specify A as the source vertex
    distance[0] = 0;

    bool r = bellman_ford_shortest_paths(g, int (n_vertices),
                                        boost::weight_map(boost::make_iterator_property_map(&edges_costs[0], get(boost::edge_index, g), edges_costs[0]))
                                        .distance_map(&distance[0])
                                        .predecessor_map(&pred[0]));

    if (r)
        for (int i = 0; i < n_vertices; ++i)
        std::cout << "[" <<  i << "]" << ": " << distance[i]
            << " " <<  "[" << pred[i] << "]" << std::endl;
    else
        std::cout << "negative cycle" << std::endl;

    return EXIT_SUCCESS;
}
